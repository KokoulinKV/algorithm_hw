# Задание 1.
# Подсчитать, сколько было выделено памяти под переменные в ранее разработанных программах в рамках первых трех уроков.
# Проанализировать результат и определить программы с наиболее эффективным использованием памяти.


# Урок 2 - Задание 3:
# Сформировать из введенного числа обратное по порядку входящих в него цифр и вывести на экран.
# Например, если введено число 3486, то надо вывести число 6843.

"""
Версия и разрядность ОС и интерпретатора Python:
    Python 3.9.0 (tags/v3.9.0:9cf6752, Oct  5 2020, 15:34:40) [MSC v.1927 64 bit (AMD64)] on win32

Код тестировался на тестовом числе из задания: 3468.
Вариант 1 расходует 418 байт памяти.
Вариант 2 расходует 1648 байт памяти.
Вариант 3 расходует 369 байт памяти.

Вывод:
    В результате полученных данных, самым экономным в плане памяти является варинат 3 (369 байт)с использованием
    математического способа разворота числа. Самым затратным по памяти является вариант 2 (1648 байт) с использованием
    очереди (deque).
"""

import sys
from collections import deque


# Функция для замера занимаемой памяти от множества аргументов (args):
def mem(*args):
    res = 0
    for el in args:
        if type(el) == list:
            spam = 0
            for k in el:
                spam += sys.getsizeof(k)
            res += spam
            res += sys.getsizeof(el)
        elif type(el) == deque:
            eggs = 0
            for k in el:
                eggs += sys.getsizeof(k)
            res += eggs
            res += sys.getsizeof(el)
        else:
            res += sys.getsizeof(el)
    return res


# Вариант 1. Через list.

num = input('Введите целое число: ')  # 3486

lst = []
for i in range(len(num) - 1, -1, -1):
    lst.append(num[i])
new_num1 = ''.join(lst)

print('Вариант 1.')
print(f'Введенное число: {num}')
print(f'Конечное число: {new_num1}')
# В качестве аргумента 'i' можно использовать '0', т.к. при любом введеном num,
# цикл в варианте 2 идот до i = 0 включительно:
print(f'Затраченая память на вариант 1: {mem(num, lst, i, new_num1)} байт.')  # 418 байт

# Вариант 2. Через deque.

num_deq = deque(num)
num2 = num_deq.copy()

new_num2 = deque()
while num2:
    new_num2.append(num2.pop())

print('Вариант 2.')
print(f'Введенное число: {"".join(num_deq)}')
print(f'Конечное число: {"".join(new_num2)}')
print(f'Затраченая память на вариант 2: {mem(num_deq, new_num2)} байт.')  # 1648 байт

# Вариант 3. Через int и деления //, %.

num_int = int(num)
num3 = num_int
lst3 = []

while num3:
    lst3.append(f'{num3 % 10}')
    num3 = num3 // 10

new_num3 = ''.join(lst3)
print('Вариант 3.')
print(f'Введенное число: {num_int}')
print(f'Конечное число: {new_num3}')
print(f'Затраченая память на вариант 3: {mem(num_int, lst3, new_num3)} байт.')  # 369 байт
